def algorithmOBST(p, q, n):
    w = [[0]*(n+2) for _ in range(n+2)]
    e = [[0]*(n+2) for _ in range(n+2)]
    root = [[0]*(n+2) for _ in range(n+2)]
    for i in range(1, n+2):
        w[i][i-1] = q[i-1]
        e[i][i-1] = q[i-1]
    for k in range(1, n+1):
        for i in range(1, n-k+2):
            j = i + k - 1
            w[i][j] = w[i][j-1] + p[j] + q[j]
            e[i][j] = float('inf')
            for r in range(i, j+1):
                t = e[i][r-1] + e[r+1][j] + w[i][j]
                if t < e[i][j]:
                    e[i][j] = t
                    root[i][j] = r
    return e, w, root
def print_matrix(mat, n, name):
    print(f"Matrix {name}:")
    for i in range(1, n+2):
        row = []
        for j in range(n+1):
            if j < i-1:
                row.append('-')
            else:
                val = mat[i][j]
                if isinstance(val, float):
                    row.append(f"{val:.4f}")
                else:
                    row.append(str(val))
        print(" ".join(row))

n = int(input("Enter number of book IDs:"))
keys = list(map(int, input(f"Enter {n} sorted book IDs: ").split()))
p_values = list(map(float, input(f"Enter {n} probabilities of successful searches:").split()))
q_values = list(map(float, input(f"Enter {n+1} probabilities of unsuccessful searches:").split()))
p = [0] + p_values
q = q_values
e, w, root = algorithmOBST(p, q, n)
print(f"Minimum Expected Cost of OBST:{e[1][n]:.4f}")
print_matrix(w, n, "w")
print_matrix(e, n, "e")
print_matrix(root, n, "root")
